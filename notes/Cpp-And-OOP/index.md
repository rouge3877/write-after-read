---
date: 2023-11-01
title: Cpp-And-OOP
---


# `C++ & OOP` Supplements

## 1. Constructors

### Four Way to Call Constructors

* 调用无参构造函数

  * ```c++
    //调用无参构造函数
    Person p;
    ```

  * **注意1**：**<u>调用无参构造函数不能加括号</u>**，如果加了编译器认为这是一个函数声明。如 `Person p2();`

* 括号法

  * ```c++
    //1. 括号法，常用
    Person p1(10);
    Person p2(p1); //拷贝构造函数
    ```

* 显示法

  * ```c++
    //2 显式法
    Person p2 = Person(10); 
    Person p3 = Person(p2);
    //Person(10)单独写就是匿名对象; 特点：当前行执行结束后，系统会立即回收掉匿名对象
    ```

* 隐式转换法

  * ```c++
    //3 隐式转换法
    Person p4 = 10; // 相当于写了 Person p4 = Person(10); 隐式的转换为显示法。 
    Person p5 = p4; // Person p5 = Person(p4); 
    ```

  * **注意2**：**<u>不要利用拷贝构造函数初始化匿名对象</u>**，如 `Person(p7)` ， 编译器会认为 `Person(p7)` 这个语法等价于 `Person p7` ，编译器会认为是对象声明，程序会因为重定义报错。

* 1.当用一个对象去初始化同类的另一个对象时

  ```c++
  Complex c2(c1);
  Complex c2 = c1;
  ```

  这两语句是等价的但是要注意此时`Complex c2 = c1`是一个初始化语句, 并非一个赋值语句赋值语句是一个已经初始化后的变量 如下：

  ```c++
  Complex c1, c2; c1 = c2 ;
  c1=c2;
  ```

  赋值语句不会触发拷贝构造


### 拷贝构造函数调用时机

* 使用一个已经创建完毕的**对象**来初始化一个新对象

  * ```c++
    //1.使用一个已经创建完毕的对象来初始化一个新对象 
    Personp p1(20);
    Personp p2(p1);
    ```

* **值传递**的方式给函数参数传值

  * ```c++
    //2.值传递的方式给函数参数传值
    void doWork(Personp p4){} 
    Personp p3;
    doWork(p3); //实参传给形参的时候就是直接使用的拷贝构造函数
    ```

  * 实参传给形参的时候就是直接使用的拷贝构造函数

* 以**值方式**返回局部对象

  * ```c++
    //3.以值方式返回局部对象
    Personp doWork2(){
    	Personp p5;
        cout << "p5的地址为:" << &p5 << endl;
    	return p5;  //因为是返回的值,其实是使用通过拷贝构造函数将p5赋值一份再返回,然后p5被释放.
    }

    Personp p6 = doWork2();
    cout << "p6的地址为:" << &p6 << endl;
    ```

  * 因为是返回的值，其实是使用**通过拷贝构造函数将`p5`赋值一份**再返回，然后**`p5`被释放**


### 构造函数可访问性

通常情况下，我们将构造函数声明为public的，可以供外部调用。然而有时候我们会将构造函数声明为private或protected的

1. 如果类的作者不希望用户直接构造一个类对象，着只是希望用户构造这个类的子类，那么就可以将构造函数声明为protected，而将该类的子类声明为public
2. 如果将构造函数声明为private，那只有这个类的成员函数才能构造这个类的对象

### 构造函数默认添加规则

默认情况下, c++编译器至少给一个类添加3个函数

1. 默认**无参**构造函数(无参, 函数体为空)
2. 默认拷贝构造函数, 对属性进行值拷贝
3. 默认析构函数(无参, 函数体为空)

构造函数默认添加规则如下：

- 如果用户定义有参构造函数, c++不提供**默认无参**构造, 但是会提供默认拷贝构造 

  - ```c++
    //如果用户提供有参构造, 编译器不会提供默认构造, 会提供拷贝构造
    ClassName p1; //此时如果用户自己没有提供默认构造, 会出错
    ClassName p2(10); //用户提供的有参构造函数
    ClassName p3(p2); //此时如果用户没有提供拷贝构造, 编译器会提供
    ```


- 如果用户定义拷贝构造函数, c++不会再提供**其他构造函数** 

  - ```c++
    //如果用户提供拷贝构造, 编译器不会提供其他构造函数
    ClassName p4; //此时如果用户自己没有提供默认构造, 会出错
    ClassName p5(10); //此时如果用户自己没有提供有参, 会出错
    ClassName p6(p5); //用户自己提供拷贝构造
    ```

### initializer_list

> [C++构造函数为什么要依赖初始化列表？ - 安然编程的回答 - 知乎](https://www.zhihu.com/question/485487580/answer/)

> ***<u>需要强调</u>***:
>
> ```c++
> class Date{
> public:
>     ...
> private:
>     //这里的成员变量是定义吗？
>     int _year;
>     int _month;
>     int _day;
> }
> ```
>
> 类中的成员变量**只是声明, 并不是定义**定义的标志是为其开辟空间 那成员变量在哪里定义的呢？ 答案是：**初始化列表可认为是对象的成员变量定义的地方**

1. **语法**：`ClassName(): 属性1(值1),属性2(值2) ... {method body}`

2. 构造函数体内的语句只能将其称作为赋初值, 而不能称之为初始化因为初始化只能初始化一次, 而构造函数体内可以多次赋值

3. 总结:

   1. 每个成员变量在初始化列表中只能出现一次, 因为初始化列表是成员变量定义的地方, 只能定义一次

   2. 以下成员必须放在初始化列表初始化:

      - 引用成员变量: 引用类型的变量必须在定义的时候初始化
      - const 成员变量（准确来说是非静态的const成员变量）
      - 自定义类型成员（且该类没有默认构造函数）

   3. 成员变量<u>**在类中的声明次序**</u>就是其在初始化列表中的**初始化顺序**, 与其在初始化列表的先后次序无关

      > ```c++
      > class A
      > {
      > public:
      >     A(int a)
      >         :_a1(a)
      >         ,_a2(_a1)
      >     {}
      >
      >     void Print()
      >     {
      >         cout << _a1 << " " << _a2 << endl;
      >     }
      > private:
      >     //先声明的是_a2,后声明的是_a1
      >     int _a2;
      >     int _a1;
      > };
      >
      > int main()
      > {
      >     A aa(1);
      >     aa.Print();
      >     return 0;
      > }
      > ```
      >
      > A. 输出 `1 1`  B. 程序崩溃 C.编译不通过 D.输出`1 随机值`
      >
      > 解析：很明显, 先声明的是`_a2`, 后声明的是`_a1`, 所以先初始化`_a2`,再初始化`_a1`, 答案选D

## `Static` Mumber, `this` pointer and `const` method

### 静态成员变量

- 所有对象共享同一份数据
- 在编译阶段分配内存: **静态成员变量在对象创建之前就已经被分配了内存空间** (即使不定义对象, 也可以为静态成员变量分配空间, 进而可以使用静态成员变量)
- 编译器在遇到初始化语句时才为静态数据成员分配空间，所以不写初始化语句必然编译错误
- 在类内声明, **初始化静态成员变量要在类的外面进行**: `typeName className::variable = ...`    [BTW]: when Initialize a static mumber, ***<u>TypeName is necessary!!!</U>***
- For `static` `private` mumber:
  - 静态成员变量也是有访问权限的
  - 类内声明, **类外初始化**
  - 在外部, 私有权限访问不到
- [A Questions about `headerfile`, initailize `static` variable and `Linker`](https://stackoverflow.com/questions/185844/how-to-initialize-private-static-data-members-in-a-header-file/185848#185848) on stackoverflow

### 静态成员函数

- 静态成员函数**只能访问静态成员变量** (Beacuse `static` function doesn't have `this` pointer to point a specific object)
- **<u>`static`成员函数只能访问`static`成员变量, 非`static`成员函数可以访问`static`成员变量</u>**

### 对象空间(storage about an instance of Class)

- 非静态成员变量占对象空间
- 函数不占对象空间, 所有函数共享一个函数实例
- 静态成员变量, 静态成员函数也不占对象空间

### `this`指针 (非静态成员函数中)

- **`this`指针指向被调用的成员函数所属的对象**

- 当形参和成员变量同名时, 可用`this`指针来区分

- 在类的非静态成员函数中返回对象本身, 可使用`return *this`

- c++中空指针也是可以调用成员函数的, 但是也要注意有没有用到this指针

  ```c++
  class Person {
  public:
      void ShowClassName() {
          cout << "我是Person类!" << endl;
      }
      void ShowPerson() {
          if (this == NULL) { return; }
          cout << _mAge << endl;
      }

  public:
      int _mAge;
  };

  int main(){
      Person * p = NULL;
      p->ShowClassName(); //空指针, 可以调用成员函数
      p->ShowPerson();  //但是如果成员函数中用到了this指针, 就不可以了
      return 0;
  }
  ```

### `Const` 修饰成员函数

- 将`const`修饰的类成员函数称之为`const`成员函数, `const`修饰类成员函数, 实际修饰该成员函数隐含的`this`指针, 表明在该成员函数中**不能对类的任何成员进行修改**

  - `void clsName::show() const {}`
  - `void clsName::show(const clsName* this)`

- **`const` 关键字不能与 `static` 关键字同时使用**, 因为 `static` 关键字修饰静态成员函数, 静态成员函数不含有 `this` 指针, 即不能实例化, `const` 成员函数必须具体到某一实例

- **权限可以被缩小但不能被放大**

  - `const` 对象**不允许**调用 `non-const` 的成员方法
  - `non-const` 对象可以调用 `const` 的成员方法
  - `const` 成员方法内**不允许**调用其它的 `non-const` 的成员方法
  - `non-const` 成员方法内可以调用其它的 `const` 的成员方法

- 通过区分成员函数是否是const的，可以对其进行**重载**。因为非常量版本的函数对于常量对象是不可用的，所以只能在一个常量对象上调用const成员函数。另一方面，虽然可以在常量对象上调用常量或非常量版本的函数，但显然此时非常量版本是一个更好的匹配。所以此时，对象是否是const的决定了应该调用哪个函数

- `const`成员函数返回的`this`引用也是`const &a`, 如果把`A&`前面的`const`去掉会出错。因为返回的是一个`const`的对象，返回类型却不是`const`。返回的内容和返回的类型不符

  ```c++
  const A& Test1()const{   
      return *this;  
  }
  ```

## 类的定义, 声明, 初始化

> [C++中的类——类的定义和声明](https://blog.csdn.net/qq_37568748/article/details/81938275) || [C/C++语言中的声明](https://blog.csdn.net/qq_37568748/article/details/80677557) || [C++中的初始化](https://blog.csdn.net/qq_37568748/article/details/81241008), [一文总结现代 C++ 中的初始化](https://xie.infoq.cn/article/63aff5cc0b896f4bd1e8f3ed3)

- 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，以一个新值来代替
- 类中成员变量被初始化的顺序**与成员变量在类中声明的先后顺序一致**, 与构造函数中被初始化的先后顺序无关

### 类的定义

- [**数据成员**]c++11新标准规定，可以为数据成员提供一个类内初始值。在创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。但是需要注意：**类内初始值要么放在等号右边，要么放在花括号内，记住不能使用圆括号。**
- [**方法成员**]所有成员的声明都必须在类的内部，但是成员函数体的定义则既可以在类的内部也可以在类的外部。在类的外部定义成员函数时，必须同时提供类名和函数名。一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。结果就是我们可以直接使用类的其他成员而无需再次授权了。**但是函数的返回类型通常出现在类名之前，所以返回类型中使用的名字都位于类的作用域之外。如果需要使用类中的类型成员作为返回类型，则必须指明它是哪个类的成员。**

### 类的声明`class 类名;`

- 我们可以仅仅声明类而暂时不定义它，这种声明被称为前向声明。在它声明之后定义之前该类是个**不完全类型**
- 不完全类型只能在非常有限的情况下使用：可以定义指向这种类型的**指针或引用**，也可以作为一个已经声明（**但没有定义**）的函数的**参数或返回类型**
- 对于一个类来说，在创建它的对象前必须首先完成类的定义，而不能仅仅被声明。否则编译器就无法了解这样的对象需要多少存储空间。类似的，类也必须首先被定义，然后才能用引用或者指针访问其成员。

> 简而言之：
>
> - 如果在一段代码中使用了A类实例化对象（为堆区开辟对象）或者成员变量、成员函数，那么A类必须在这段代码之前定义
> - 如果这段代码只使用A类来定义指针或者函数参数中的数据类型那么A类可以在这段代码上面声明，而在下面定义

### 对象成员

- 对象成员意义：**代码重用**(组合)

1. 参数传递问题
   - 对象成员的构造函数无参数：不需要传递
   - 若对象成员的构造函数有参数：使用构造函数初始化列表
2. 构造次序问题(析构函数与对应的构造函数的调用顺序相反)
   - first. 调用父类的构造过程
   - second. 调用成员变量的构造函数(调用顺序与声明顺序相同)
   - third. 调用类自身的构造函数

## `friend` - A way to break Encapsulation

> [github](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.md#44-%E5%8F%8B%E5%85%83) || [csdn](https://blog.csdn.net/qq_49030008/article/details/123243230)

**`friend`: <u>目的就是让类外的一些特殊函数或者类访问另一个类中私有成员</u>**

### 全局函数做友元

- 在全局函数中调用哪个类的私有成员,就使用关键字`friend`将此函数在那个类中声明即可

  ```c++
  class House{
      //声明此全局函数是一个友元
      friend void goodGay2(House& house);  
  public:
      House(): _Bedding("卧室"){}
  private:
      string _Bedding;
  };

  //全局函数
  void goodGay(House& house){
      //无法访问私有成员的
      //cout << "全局函数正在访问:" << house._Bedding << endl;  
  }
  void goodGay2(House& house){
      //因为被声明了friend,所以可以访问
      cout << "全局函数正在访问:" << house._Bedding << endl;  
  }
  ```

### 类做友元

在A类中调用B类的私有成员,就使用关键字`friend`将A类在B类中声明即可: `friend class A类的类名;`

### 成员函数做友元

有时, 我们并不想使整个类A都成为类B的友元, 而是仅仅想使A类中的某个成员函数成为B类的友元, 这时可以在B类中使用下面的语法:`friend retType A::函数名(参数列表);`

## 重载

### 函数重载

### 运算符重载`返回类型 operator<运算符符号>(参数){}`

> 1. C++编译器至少给一个类添加4个函数, One of is 赋值运算符operator=,对属性进行值拷贝
> 2. 不能改变运算符的优先级。
> 3. 不能改变运算符的结合性。
> 4. 默认参数不能和重载的运算符一起使用，也就是说，在设计运算符重载成员函数时不能使用默认函数。
> 5. 不能改变运算符的操作数的个数。
> 6. 不能创建新的运算符，只有已有运算符可以被重载
> 7. 运算符作用于C++内部提供的数据类型时，原来含义保持不变

- c++ 中有 4 个不能重载的运算符: 

  - `::` - 范围分辨率
  - `.` - 成员选择
  - `.*` - 通过函数指针选择成员
  - `?:` - 三元运算符

- 对于运算符重载函数，其所支持的参数传递方法只有

  - Pass-By-Value(按值传递)
  - Pass-By-Reference(按引用传递)
  - **在参数传递中并不支持指针**

- 对于操作符`operator=`, `operator[]`, `operator()`, `operator->`必须被定义为**非静态成员函数**

  > note: operator->为dereferencing运算符, 并且其返回值必须是一个指针或者是一个可以使用->的类对象

- 双目运算符重载

  - 带有1个参数的非静态成员函数
  - 带有2个参数的非成员函数
  - 对于任意类型的双目运算符@,则aa@bb可以被解释为aa.operator@(bb)或者operator@(aa, bb)。假如上述两种重载方式都被定义了的话，则由相应的规则(overload resolution)决定会被解释为哪种方式


- 对于单目运算符重载，不管是prefix还是postfix，也有两种方式
  - 不带参数的非静态成员函数
  - 带有1个参数的非成员函数
  - 对于任何前置(prefix)单目运算符@，@aa可以被解释为aa.operator@()或者operator@(aa),假如两种重载方式均被定义了的话，则由相应的规则(overload resolution)决定会被解释为哪种方式。
  - 对于任何后置(postfix)单目运算符@，aa@可以被解释为aa.operator@(int)或者operator@(aa, int)。同样假如两种重载方式均被定义了的话，则由相应的规则(overload resolution)决定会被解释为哪种方式。
- [特殊运算符重载](https://ivanzz1001.github.io/records/post/cplusplus/2017/11/29/cplusplus_basis3#2-%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD)

## 继承

- 继承（派生）是面向对象程序设计支持**代码重用**的重要机制
- 在**基类**的基础上创建的新类——**派生类**, 从而形成层次或等级关系也便于对类进行组织
  - **获得**一个或多个原有类中的方法和属性
  - 可以**增加**新的数据成员和成员函数
  - 通过派生方式，可以**修改**现有成员的访问控制权限
  - 可以**重新定义**(redefining), **重写**(overload)基类的成员函数
- **派生方式**只影响<u>**外部对基类成员的访问控制**</u>，不影响派生类新成员对其的访问

### 派生类的构造和析构

- **构造、析构函数不继承**，但创建派生类对象时都被调用

- 构造次序问题(析构函数与对应的构造函数的调用顺序相反)

  - first. 调用**父类**的构造过程
  - second. 调用成员变量的构造函数(调用顺序与声明顺序相同)
  - third. 调用类**自身**的构造函数

- 派生类构造函数向基类构造函数传参数

  - 基类的构造函数没有参数，或者没有显式地定义构造函数的时候，派生类构造函数不必考虑向基类构造函数传递参数，甚至可以不定义构造函数

  - 当基类中带有参数的构造函数的时候，派生类必须定义构造函数，且**使用初始化列表传递参数**

    - 派生类中构造函数的格式（显式传参）

    ```c++
    派生类构造函数名（形参表）:基类构造函数名（实参表）
    //显式调用基类的构造函数, 去掉则为隐式调用
    {
        ...... 
        //对新成员的构造
    }
    /*-----------*/
    Circle::Circle(double r, int a, int b):Point(a, b)
    {
        radius = r;
        
        cout<<"Circle constructor:radius is "
        <<radius<<"["<<x<<","<<y<<"]"<<endl;
    }
    ```

### 重新定义(redefining)

- 在派生类中定义与基类成员函数**首部完全相同**的成员函数
- 学习重新定义的目的: 理解**重写**  (重写 $\sub$ 重新定义)
  - 一般情况**不要**重新定义(redefining), 没多大意义
  - 而是采用重写(override): 不由编译器决定调用哪个函数
- 理解重新定义存在的两种现象
  - 在派生类中，基类成员函数被**隐藏**: 派生类确实继承了基类同名函数, 但被隐藏 (通过特殊方式可访问)
  - **窄化**现象: 反过来, 派生类的重新定义函数可能被隐藏--**窄化**
  - ***尽管效果相反，但本质上一致: 由编译器决定调用的是继承或重新定义的函数，仍是重载的范畴***

```c++
#include <iostream>
using namespace std;
/*声明基类*/
class Base{
    int b;
public:
    Base(int sb):b(sb){}

    int getNum(){
        return b;
    }
};

class Z: public Base{
    int c;
public:
    Z(int sb,int sc):Base(sb), c(sc){}
    int getNum(){
        return c;
    } //重新定义
};

int main {
    Z obj(4, 6); //派生类对象obj
    cout << "c=" << obj.getNum() << endl;//1. 隐藏了基类成员函数
    cout << "b=" << obj.Y::getNum() << endl;//2. 确实有两个getNum
    Base *p = &obj; //3. 派生类对象属于基类, 合法
    cout << "b=" << p->getNum() << endl; //4. 调用的是base::getNum  (类似java的窄化)
    return 0;
}
```